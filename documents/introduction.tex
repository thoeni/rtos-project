\markright{Introduction}

\section{Introduction}
In 2011, 48.8\% of the smartphones on the market, ran Android OS, contributing to an annual growth of 244\%.\footnote{Source: Canalys. February 2012} This is what an average customer can easily guess by himself. What not everyone can figure, unless he's working in this very specific field, is that lately Android OS - and therefore its open source project AOSP - aroused the curiosity of many embedded developers. Despite not being as "lightweight and small footprint"-centric as other \textit{Real Time Operating System}, Android still offers a lot of opportunities to Embedded Developers: first of all, a very intuitive graphic interface. While a large number of embedded devices have little to no human interface, a substantial number of devices which would traditionally be considered "embedded" do have user interfaces. In this field, Android comes as a bridge connecting the users that are already familiar with its interface, to embedded systems they need to interact with.\\
Despite in the past, common GUI were window-centric and desktop-like, after iOS and Android birth the way people interact with mobile instruments and devices has changed, towards a more touch-based experience. This change, combined with Android's open source licensing, has been a terrific mix that increased embedded developers' interest in Android open source project.\\
This work will analyze Android's structure, to better understand the whole flow which goes from Java App (which is called Activity) to the native code, running below anything, and just above the kernel. All this will be done through a very simple example, where a native daemon running throughout the whole Android's execution will be able to grant some dummy resources (we called cores) to a Java application requiring them. This communication will go through the whole stack in a top down approach relying on JNI interface. A small bottom up example which uses a \textit{callback} function will be presented as well.